/*
 * generated by Xtext 2.14.0
 */
package imp.lang.xtext.serializer;

import com.google.inject.Inject;
import imp.lang.xtext.services.ImpGrammarAccess;
import imp.model.imp.Assignment;
import imp.model.imp.AttributeDecl;
import imp.model.imp.Binary;
import imp.model.imp.Block;
import imp.model.imp.BoolConst;
import imp.model.imp.Declaration;
import imp.model.imp.If;
import imp.model.imp.ImpPackage;
import imp.model.imp.IntConst;
import imp.model.imp.MethodDecl;
import imp.model.imp.NewClass;
import imp.model.imp.ParamDecl;
import imp.model.imp.Print;
import imp.model.imp.Program;
import imp.model.imp.Project;
import imp.model.imp.Return;
import imp.model.imp.StringConst;
import imp.model.imp.This;
import imp.model.imp.Unary;
import imp.model.imp.VarRef;
import imp.model.imp.While;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ImpSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ImpGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ImpPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ImpPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case ImpPackage.ATTRIBUTE_DECL:
				sequence_AttributeDecl(context, (AttributeDecl) semanticObject); 
				return; 
			case ImpPackage.BINARY:
				sequence_Binary(context, (Binary) semanticObject); 
				return; 
			case ImpPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case ImpPackage.BOOL_CONST:
				sequence_BoolConst(context, (BoolConst) semanticObject); 
				return; 
			case ImpPackage.CLASS:
				sequence_Class(context, (imp.model.imp.Class) semanticObject); 
				return; 
			case ImpPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case ImpPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case ImpPackage.INT_CONST:
				sequence_IntConst(context, (IntConst) semanticObject); 
				return; 
			case ImpPackage.METHOD_DECL:
				sequence_MethodDecl(context, (MethodDecl) semanticObject); 
				return; 
			case ImpPackage.NEW_CLASS:
				sequence_NewClass(context, (NewClass) semanticObject); 
				return; 
			case ImpPackage.PARAM_DECL:
				sequence_ParamDecl(context, (ParamDecl) semanticObject); 
				return; 
			case ImpPackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case ImpPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ImpPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case ImpPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case ImpPackage.STRING_CONST:
				sequence_StringConst(context, (StringConst) semanticObject); 
				return; 
			case ImpPackage.THIS:
				sequence_This(context, (This) semanticObject); 
				return; 
			case ImpPackage.UNARY:
				sequence_Unary(context, (Unary) semanticObject); 
				return; 
			case ImpPackage.VAR_REF:
				sequence_VarRef(context, (VarRef) semanticObject); 
				return; 
			case ImpPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Stmt returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (lhs=Expr rhs=Project)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.ASSIGNMENT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.ASSIGNMENT__LHS));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.ASSIGNMENT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.ASSIGNMENT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getLhsExprParserRuleCall_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAssignmentAccess().getRhsProjectParserRuleCall_3_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AttributeDecl returns AttributeDecl
	 *     Member returns AttributeDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AttributeDecl(ISerializationContext context, AttributeDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.ATTRIBUTE_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.ATTRIBUTE_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Binary
	 *     Expr returns Binary
	 *     Project returns Binary
	 *     Project.Project_1_0 returns Binary
	 *     Binary returns Binary
	 *     Binary.Binary_1_0 returns Binary
	 *     Unary returns Binary
	 *
	 * Constraint:
	 *     (lhs=Binary_Binary_1_0 op=BinaryOp rhs=Unary)
	 */
	protected void sequence_Binary(ISerializationContext context, Binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.BINARY__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.BINARY__LHS));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.BINARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.BINARY__OP));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.BINARY__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.BINARY__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryAccess().getBinaryLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBinaryAccess().getOpBinaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBinaryAccess().getRhsUnaryParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (stmts+=Stmt stmts+=Stmt*)?
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns BoolConst
	 *     Expr returns BoolConst
	 *     Project returns BoolConst
	 *     Project.Project_1_0 returns BoolConst
	 *     Binary returns BoolConst
	 *     Binary.Binary_1_0 returns BoolConst
	 *     Unary returns BoolConst
	 *     Atomic returns BoolConst
	 *     BoolConst returns BoolConst
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BoolConst(ISerializationContext context, BoolConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Class returns Class
	 *
	 * Constraint:
	 *     (name=ID attributes+=AttributeDecl* methods+=MethodDecl*)
	 */
	protected void sequence_Class(ISerializationContext context, imp.model.imp.Class semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Declaration
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (name=EString exp=Expr)
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.DECLARATION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.DECLARATION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclarationAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDeclarationAccess().getExpExprParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (cond=Expr lhs=Stmt rhs=Stmt)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.IF__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.IF__COND));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.IF__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.IF__LHS));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.IF__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.IF__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getCondExprParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getIfAccess().getLhsStmtParserRuleCall_4_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getIfAccess().getRhsStmtParserRuleCall_5_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns IntConst
	 *     Expr returns IntConst
	 *     Project returns IntConst
	 *     Project.Project_1_0 returns IntConst
	 *     Binary returns IntConst
	 *     Binary.Binary_1_0 returns IntConst
	 *     Unary returns IntConst
	 *     Atomic returns IntConst
	 *     IntConst returns IntConst
	 *
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_IntConst(ISerializationContext context, IntConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.INT_CONST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.INT_CONST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntConstAccess().getValueEIntParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MethodDecl returns MethodDecl
	 *     Member returns MethodDecl
	 *
	 * Constraint:
	 *     (name=ID (params+=ParamDecl params+=ParamDecl*)? stmt=Stmt)
	 */
	protected void sequence_MethodDecl(ISerializationContext context, MethodDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns NewClass
	 *     Expr returns NewClass
	 *     Project returns NewClass
	 *     Project.Project_1_0 returns NewClass
	 *     Binary returns NewClass
	 *     Binary.Binary_1_0 returns NewClass
	 *     Unary returns NewClass
	 *     Atomic returns NewClass
	 *     NewClass returns NewClass
	 *
	 * Constraint:
	 *     class=[Class|ID]
	 */
	protected void sequence_NewClass(ISerializationContext context, NewClass semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.NEW_CLASS__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.NEW_CLASS__CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNewClassAccess().getClassClassIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ImpPackage.Literals.NEW_CLASS__CLASS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParamDecl returns ParamDecl
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ParamDecl(ISerializationContext context, ParamDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.PARAM_DECL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.PARAM_DECL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamDeclAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     expr=Expr
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.PRINT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.PRINT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintAccess().getExprExprParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     ((classes+=Class+ methods+=MethodDecl+) | methods+=MethodDecl+)?
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Project
	 *     Expr returns Project
	 *     Project returns Project
	 *     Project.Project_1_0 returns Project
	 *     Binary returns Project
	 *     Binary.Binary_1_0 returns Project
	 *     Unary returns Project
	 *
	 * Constraint:
	 *     (lhs=Project_Project_1_0 rhs=[Member|ID] (ismethodcall?='(' (params+=Expr params+=Expr*)?)?)
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Return
	 *     Return returns Return
	 *
	 * Constraint:
	 *     expr=Expr
	 */
	protected void sequence_Return(ISerializationContext context, Return semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.RETURN__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.RETURN__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnAccess().getExprExprParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns StringConst
	 *     Expr returns StringConst
	 *     Project returns StringConst
	 *     Project.Project_1_0 returns StringConst
	 *     Binary returns StringConst
	 *     Binary.Binary_1_0 returns StringConst
	 *     Unary returns StringConst
	 *     Atomic returns StringConst
	 *     StringConst returns StringConst
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringConst(ISerializationContext context, StringConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.STRING_CONST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.STRING_CONST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringConstAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns This
	 *     Expr returns This
	 *     Project returns This
	 *     Project.Project_1_0 returns This
	 *     Binary returns This
	 *     Binary.Binary_1_0 returns This
	 *     Unary returns This
	 *     Atomic returns This
	 *     This returns This
	 *
	 * Constraint:
	 *     {This}
	 */
	protected void sequence_This(ISerializationContext context, This semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Unary
	 *     Expr returns Unary
	 *     Project returns Unary
	 *     Project.Project_1_0 returns Unary
	 *     Binary returns Unary
	 *     Binary.Binary_1_0 returns Unary
	 *     Unary returns Unary
	 *
	 * Constraint:
	 *     (op=UnaryOp expr=Unary)
	 */
	protected void sequence_Unary(ISerializationContext context, Unary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.UNARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.UNARY__OP));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.UNARY__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.UNARY__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getOpUnaryOpEnumRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryAccess().getExprUnaryParserRuleCall_1_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns VarRef
	 *     Expr returns VarRef
	 *     Project returns VarRef
	 *     Project.Project_1_0 returns VarRef
	 *     Binary returns VarRef
	 *     Binary.Binary_1_0 returns VarRef
	 *     Unary returns VarRef
	 *     Atomic returns VarRef
	 *     VarRef returns VarRef
	 *
	 * Constraint:
	 *     ref=[Symbol|ID]
	 */
	protected void sequence_VarRef(ISerializationContext context, VarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.VAR_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.VAR_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarRefAccess().getRefSymbolIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ImpPackage.Literals.VAR_REF__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     (cond=Expr body=Stmt)
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.WHILE__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.WHILE__COND));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.WHILE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.WHILE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getCondExprParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileAccess().getBodyStmtParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
