/*
 * generated by Xtext 2.14.0
 */
package imp.lang.xtext.serializer;

import com.google.inject.Inject;
import imp.lang.xtext.services.ImpGrammarAccess;
import imp.model.imp.ArrayDecl;
import imp.model.imp.Assign;
import imp.model.imp.Binary;
import imp.model.imp.Block;
import imp.model.imp.BoolConst;
import imp.model.imp.If;
import imp.model.imp.ImpPackage;
import imp.model.imp.IntConst;
import imp.model.imp.Skip;
import imp.model.imp.Unary;
import imp.model.imp.Var;
import imp.model.imp.While;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ImpSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ImpGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ImpPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ImpPackage.ARRAY_DECL:
				sequence_ArrayDecl(context, (ArrayDecl) semanticObject); 
				return; 
			case ImpPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case ImpPackage.BINARY:
				sequence_Binary(context, (Binary) semanticObject); 
				return; 
			case ImpPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case ImpPackage.BOOL_CONST:
				sequence_BoolConst(context, (BoolConst) semanticObject); 
				return; 
			case ImpPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case ImpPackage.INT_CONST:
				sequence_IntConst(context, (IntConst) semanticObject); 
				return; 
			case ImpPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case ImpPackage.UNARY:
				sequence_Unary(context, (Unary) semanticObject); 
				return; 
			case ImpPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case ImpPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expr returns ArrayDecl
	 *     ArrayDecl returns ArrayDecl
	 *
	 * Constraint:
	 *     (values+=Expr values+=Expr*)?
	 */
	protected void sequence_ArrayDecl(ISerializationContext context, ArrayDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Assign
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     (name=EString index=Expr? exp=Expr)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Binary
	 *     Binary returns Binary
	 *
	 * Constraint:
	 *     (op=BinaryOp lhs=Expr rhs=Expr)
	 */
	protected void sequence_Binary(ISerializationContext context, Binary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.BINARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.BINARY__OP));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.BINARY__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.BINARY__LHS));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.BINARY__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.BINARY__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryAccess().getOpBinaryOpEnumRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBinaryAccess().getLhsExprParserRuleCall_4_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBinaryAccess().getRhsExprParserRuleCall_6_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (stmts+=Stmt stmts+=Stmt*)?
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns BoolConst
	 *     BoolConst returns BoolConst
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_BoolConst(ISerializationContext context, BoolConst semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (cond=Expr lhs=Stmt rhs=Stmt)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.IF__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.IF__COND));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.IF__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.IF__LHS));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.IF__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.IF__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getCondExprParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getIfAccess().getLhsStmtParserRuleCall_4_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getIfAccess().getRhsStmtParserRuleCall_5_1_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns IntConst
	 *     IntConst returns IntConst
	 *
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_IntConst(ISerializationContext context, IntConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.INT_CONST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.INT_CONST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntConstAccess().getValueEIntParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns Skip
	 *     Skip returns Skip
	 *
	 * Constraint:
	 *     {Skip}
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Unary
	 *     Unary returns Unary
	 *
	 * Constraint:
	 *     (op=UnaryOp expr=Expr)
	 */
	protected void sequence_Unary(ISerializationContext context, Unary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.UNARY__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.UNARY__OP));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.UNARY__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.UNARY__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getOpUnaryOpEnumRuleCall_2_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getUnaryAccess().getExprExprParserRuleCall_3_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expr returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (name=EString index=Expr?)
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Stmt returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     (cond=Expr body=Stmt)
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.WHILE__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.WHILE__COND));
			if (transientValues.isValueTransient(semanticObject, ImpPackage.Literals.WHILE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ImpPackage.Literals.WHILE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getCondExprParserRuleCall_2_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileAccess().getBodyStmtParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
