/*
 * generated by Xtext 2.10.0
 */
package org.tetrabox.minijava.xtext.fortest.scoping

import com.google.inject.Inject
import miniJava.interpreter.miniJava.Assignment
import miniJava.interpreter.miniJava.Block
import miniJava.interpreter.miniJava.FieldAccess
import miniJava.interpreter.miniJava.ForStatement
import miniJava.interpreter.miniJava.Method
import miniJava.interpreter.miniJava.MethodCall
import miniJava.interpreter.miniJava.MiniJavaPackage
import miniJava.interpreter.miniJava.VariableDeclaration
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.MapBasedScope
import org.tetrabox.minijava.xtext.fortest.MiniJavaModelUtil
import org.tetrabox.minijava.xtext.fortest.typing.MiniJavaTypeComputer

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class MiniJavaScopeProvider extends AbstractMiniJavaScopeProvider {

	val epackage = MiniJavaPackage.eINSTANCE
	@Inject extension MiniJavaModelUtil
	@Inject extension MiniJavaTypeComputer

	override getScope(EObject context, EReference reference) {
		println('''«reference» ////// «epackage.symbolRef_Symbol»''')
		if (reference == epackage.symbol_ref_Symbol) {
			return scopeForSymbolRef(context)
		} else if (reference == epackage.method_call_Method) {
			val res = scopeForMethodCall(context as MethodCall)
			return res
		} else if (context instanceof MethodCall) {
			return scopeForMethodCall(context)
		} else if (context instanceof FieldAccess) {
			return scopeForFieldAccess(context)
		}
		return super.getScope(context, reference)
	}

	// TODO field access? (not required, we have 'this')
	// TODO variable declaration atop for loop
	def protected IScope scopeForSymbolRef(EObject context) {
		val container = context.eContainer
		return switch (container) {
			Method:
				Scopes.scopeFor(container.params)
			Block: {
				val lst = container.statements.takeWhile[it != context].filter(Assignment).map[it.assignee].filter(
					VariableDeclaration).toList

				val tmp = MapBasedScope.createScope(scopeForSymbolRef(container), lst.map [
					EObjectDescription.create(it.name, it)
				])

				return tmp

			}
			ForStatement:
				Scopes.scopeFor(
					#[container.declaration.assignee],
					scopeForSymbolRef(container) // outer scope
				)
			default:
				scopeForSymbolRef(container)
		}
	}

	// TODO simplify?
	def IScope scopeForFieldAccess(FieldAccess sel) {
		val type = sel.receiver.typeFor

		if (type === null || type.isPrimitive)
			return IScope.NULLSCOPE

		val grouped = type.classHierarchyMembers.groupBy[it instanceof Method]
		val inheritedMethods = grouped.get(true) ?: emptyList
		val inheritedFields = grouped.get(false) ?: emptyList

		return Scopes.scopeFor(
			type.fields + type.methods,
			Scopes.scopeFor(inheritedFields + inheritedMethods)
		)
	}

	// TODO simplify?
	def IScope scopeForMethodCall(MethodCall sel) {
		val type = sel.receiver.typeFor

		if (type === null || type.isPrimitive)
			return IScope.NULLSCOPE

		val grouped = type.classHierarchyMembers.groupBy[it instanceof Method]
		val inheritedMethods = grouped.get(true) ?: emptyList
		val inheritedFields = grouped.get(false) ?: emptyList

//		val typeScope = (type.methods + type.fields).toList
//		new MapBasedScope(Scopes.scopeFor(inheritedMethods + inheritedFields), false)
//		val tmp = Scopes.scopeFor(
//			typeScope,
//			
//		)
		val tmp = MapBasedScope.createScope(Scopes.scopeFor(inheritedMethods + inheritedFields), type.methods.map [
			EObjectDescription.create(it.name, it)
		])
		return tmp
	}

}
