behavior imp_exec;

use execimp.MapService;

open class Stmt {
	def Store execute(Store s) {
		result := s;
	}
}

open class Skip {
	def Store execute(Store s) {
		result := s;
	}
}

open class Assign {
	def Store execute(Store s) {
		s.values.put(self.name, self.exp.evaluate(s));
		result := s;
	}
}

open class Block {
	def Store execute(Store s) {
		result := s;
		for(e in self.stmts) {
			result := e.execute(result);
		}
	}
}

open class If {
	def Store execute(Store s) {
		Value conde := self.cond.evaluate(s);
		
		result := s;
		
		if(conde.oclIsKindOf(imp::BoolValue)) {
			imp::BoolValue condeb := conde;
			if(condeb.value) {
				result := self.lhs.execute(s);
			} else {
				result := self.rhs.execute(s);
			}
		}
	}
}

open class While {
	def Store execute(Store s) {
		boolean stop := false;
		Store tmp := s;
		while(not stop) {
			Value conde := self.cond.evaluate(s);
			if(conde.oclIsKindOf(imp::BoolValue)) {
				imp::BoolValue condeb := conde;
				if(condeb.value) {
					tmp := self.body.execute(tmp);
				} else {
					stop := true;
				}
			} else {
				stop := true;
			}
		}
		result := tmp;
	}
}


open class Expr {
	def Value evaluate(Store s) {
		result := imp::IntValue.create();
	}
}

open class IntConst {
 	def Value evaluate(Store s) {
 		IntValue tmp := imp::IntValue.create();
		tmp.value := self.value;
		result := tmp;
 	}
}

open class Var {
	def Value evaluate(Store s) {
		result := s.values.get(self.name);		
	}
}

//open class Unary {
//	def Value evaluate(Store s) {
//		//Value ev := self.expr.evaluate(s);
////		if(self.op == imp::UnaryOp.Negate) {
////			if(ev.oclIsKindof(imp::IntValue)) {
////				imp::IntValue tmp := ev;
////				result := boa::IntValue.create();
////				result.value := tmp.value;
////			}		
////		}
//	}
//}